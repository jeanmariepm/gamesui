{"ast":null,"code":"class Game {\n  constructor() {\n    this.squares = Array(9).fill(null);\n\n    this.calculateWinner = squares => {\n      const lines = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]];\n\n      for (let i = 0; i < lines.length; i++) {\n        const [a, b, c] = lines[i];\n\n        if (squares[a] !== null && squares[a] === squares[b] && squares[a] === squares[c]) {\n          return this.squares[a];\n        }\n      }\n\n      return null;\n    };\n\n    this.minmax = (squares, player, depth = 0) => {\n      console.log(`minmax exploring ${squares} ${player}`);\n      let next_val = 0;\n      let action = -1;\n      const best_val = player === \"X\" ? 1 : -1;\n      const next_player = player === \"X\" ? \"O\" : \"X\"; // pick a winning/loss-avoiding move if one exist\n\n      [player, next_player].forEach(cplayer => {\n        squares.forEach((element, index) => {\n          if (element === null && next_val === 0) {\n            squares[index] = cplayer;\n\n            if (this.calculateWinner(squares) === cplayer) {\n              next_val = cplayer === player ? best_val : -best_val;\n              action = index;\n            }\n\n            squares[index] = null;\n          }\n        });\n      }); // pick the best remaining\n\n      if (next_val === 0 && depth < 8) {\n        let [cnext_val, caction] = [next_val, action];\n        squares.forEach((element, index) => {\n          if (!element) {\n            squares[index] = player;\n            [next_val, action] = this.minmax(player = player === \"X\" ? \"O\" : \"X\", depth = depth + 1);\n\n            if (next_val === -best_val) {\n              [cnext_val, caction] = [next_val, action];\n            } else if (next_val === 0) {\n              [cnext_val, caction] = [next_val, action];\n            }\n\n            squares[index] = null;\n          }\n        });\n        [next_val, action] = [cnext_val, caction];\n      }\n\n      console.log(`minmax returning ${next_val} ${action}`);\n      return [next_val, action];\n    };\n  }\n\n  getWinner() {\n    return this.calculateWinner(this.squares);\n  }\n\n  isOver() {\n    if (this.squares.filter(s => s === null).length === 0) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  setAction(player, action) {\n    this.squares[action] = player;\n  }\n\n  getAIAction() {\n    // return center or top-left in first AI move\n    if (this.squares.filter(s => s === \"X\").length === 1) {\n      if (!this.squares[4]) {\n        return 4;\n      } else if (!this.squares[0]) {\n        return 0;\n      }\n    } // use minmax algorithm\n    // find action with least value by choosing opp's action with highest value\n\n\n    let [, action] = this.minmax(this.squares, \"O\");\n\n    if (action === -1) {\n      action = this.squares.findIndex(s => s === null);\n    }\n\n    return action;\n  }\n\n}\n\nexport default Game;","map":{"version":3,"sources":["/Users/jeanmariemariadassou/gamesui/ttt/src/logic/Game.js"],"names":["Game","squares","Array","fill","calculateWinner","lines","i","length","a","b","c","minmax","player","depth","console","log","next_val","action","best_val","next_player","forEach","cplayer","element","index","cnext_val","caction","getWinner","isOver","filter","s","setAction","getAIAction","findIndex"],"mappings":"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","sourcesContent":["class Game {\n  squares = Array(9).fill(null);\n\n  getWinner() {\n    return this.calculateWinner(this.squares);\n  }\n\n  isOver() {\n    if (this.squares.filter((s) => s === null).length === 0) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  calculateWinner = (squares) => {\n    const lines = [\n      [0, 1, 2],\n      [3, 4, 5],\n      [6, 7, 8],\n      [0, 3, 6],\n      [1, 4, 7],\n      [2, 5, 8],\n      [0, 4, 8],\n      [2, 4, 6],\n    ];\n    for (let i = 0; i < lines.length; i++) {\n      const [a, b, c] = lines[i];\n      if (\n        squares[a] !== null &&\n        squares[a] === squares[b] &&\n        squares[a] === squares[c]\n      ) {\n        return this.squares[a];\n      }\n    }\n    return null;\n  };\n\n  setAction(player, action) {\n    this.squares[action] = player;\n  }\n\n  getAIAction() {\n    // return center or top-left in first AI move\n    if (this.squares.filter((s) => s === \"X\").length === 1) {\n      if (!this.squares[4]) {\n        return 4;\n      } else if (!this.squares[0]) {\n        return 0;\n      }\n    }\n    // use minmax algorithm\n    // find action with least value by choosing opp's action with highest value\n\n    let [, action] = this.minmax(this.squares, \"O\");\n    if (action === -1) {\n      action = this.squares.findIndex((s) => s === null);\n    }\n    return action;\n  }\n\n  minmax = (squares, player, depth = 0) => {\n    console.log(`minmax exploring ${squares} ${player}`);\n    let next_val = 0;\n    let action = -1;\n    const best_val = player === \"X\" ? 1 : -1;\n    const next_player = player === \"X\" ? \"O\" : \"X\";\n\n    // pick a winning/loss-avoiding move if one exist\n    [player, next_player].forEach((cplayer) => {\n      squares.forEach((element, index) => {\n        if (element === null && next_val === 0) {\n          squares[index] = cplayer;\n          if (this.calculateWinner(squares) === cplayer) {\n            next_val = cplayer === player ? best_val : -best_val;\n            action = index;\n          }\n          squares[index] = null;\n        }\n      });\n    });\n    // pick the best remaining\n    if (next_val === 0 && depth < 8) {\n      let [cnext_val, caction] = [next_val, action];\n      squares.forEach((element, index) => {\n        if (!element) {\n          squares[index] = player;\n          [next_val, action] = this.minmax(\n            (player = player === \"X\" ? \"O\" : \"X\"),\n            (depth = depth + 1)\n          );\n          if (next_val === -best_val) {\n            [cnext_val, caction] = [next_val, action];\n          } else if (next_val === 0) {\n            [cnext_val, caction] = [next_val, action];\n          }\n          squares[index] = null;\n        }\n      });\n      [next_val, action] = [cnext_val, caction];\n    }\n    console.log(`minmax returning ${next_val} ${action}`);\n    return [next_val, action];\n  };\n}\n\nexport default Game;\n"]},"metadata":{},"sourceType":"module"}